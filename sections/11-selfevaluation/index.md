---
title: Self-evaluation
has_children: false
nav_order: 12
---

# Self-evaluation

Before starting the development, we collectively brainstormed ideas about the possible application to develop. Since we all appreciated the cybersecurity cpurse and we found a video about how to build a CLI password-manager, we agreed on starting from that codebase and learn how to implement cryptography. We added some additional features and also tried to create the GUI which makes more sense to reach a wider audience and also because we wanted to try creating interfaces using Python and other libraries, since until that moment we had used other languages or tools to create them. </br> We decided at the beginning how to divide the code files among us: Francesca has the parts related to the database and the general `configuration`; Filippo implemented the basic commands for `add`, `retrieve`; Alberto was in charge of the GUI with ttkbootstrap and the creation of the `pm` file; each of us would have also handled the tests for their parts. The `AES256utils.py` was already available from GitHub. We still had to divide the sections of the report. </br> Then roles changed a bit during the development due to some mishaps and hard times with keeping up with all the different individual plans, so below there is the detailed explanation of what we all ended up doing at the end:

## FRANCESCA
I set up the two main repositories for the project at the beginning (`ARTIFACT` and `REPORT`), modifying the fields that needed to (ex. `LICENSE`, `README.dm`, etc.). We discussed together about some choices, like the `LICENSE` to choose and general requirements that we absolutely wanted. >/br> I developed the whole code (both CLI and GUI) except for the files that Filippo was assigned at the beginning, but I modified them a lot while continuing the work because I wanted to add all the required and useful features. As a matter of fact, I also added many code files (like `modify.py`, `delete.py`, etc.) for functions that were not properly handled at the beginning. Since I was in charge of the database and its configuration, I also tuned with the project `MySQL Workbench` so that both databases were stored there (activating the connections and ports through `XAMPP`). I chose MySQL instead of some embedded library (like SQLite) because I wanted to use something that we had already used in other courses, also to make practice with tools that we already knew and to rely as much as possible to the knowledge we already acquired. I tried to implement all `argparse` optionalities aligned with what someone can do in the GUI. For the GUI I used ttkbootstrap and I needed to create the folder "UI" because I used the MVC pattern both for the LogIn and the main interface. </br> I modified some sections of the report, specifically `01-concept`, `02-requirements`, more or less the first half of `03-design`, `06-release`, `08-cicd`, `10-devguide`, of course `11-selfevaluation` anf `12-future`, basically I tried to cover the parts related to the code since I worked on it and had a better overview on the functionalities. </br> I come from an Economics Bachelor's, so the code was quite challenging, I was absolutely not capable of producing a perfect product and I used the AI many times when I could not solve some problems or when I needed some codebase because I clearly don't know all the possible commands, libraries and functionalities in Python so I was not able to create many things from scratch, but I feel like I learnt many things and my mind definitely got used to the kind of reasoning that is needed when programming, so I am quite satisfied with it considering I had no previous knowledge. As a matter of fact, there are for sure many inconsistencies here and there, but the code was becoming too huge to remember everything even if I tried to be precise with commits and descriptions and comments, and it was tough to always go back to the grind after a period of pause for many other academic reasons. </br> I realized that I was truly starting to understand what I was doing when, even after asking the AI for help, it occasionally made mistakes and I was able to identify many of the issues on my own. I became better at reading and interpreting the error messages that appeared, and in many cases I could find solutions independently. Overall, even though I’m not extremely skilled at coding, I managed the different phases of the process quite well and gained a clearer sense of how software engineering works internally. Trivially, I also learned a lot by letting the AI guide me toward understanding what I was doing wrong; over time, when I repeated the same or similar mistakes, I no longer needed external help because I remembered how to fix them. I genuinely hope to keep improving, since I know it will take time before I become at least decent at it, but I’m glad I made the effort to try. 

## FILIPPO
As for what it concerns my contribution to the project, I was in charge of implementing the code suites describing the main functionalities of the application. In particular, I handled the implementation of the adding (allowing the user to add a new entry to the already set up database), and the retrieval of the entries from the database. Beside these coding implementations, the part of the project that absorbed the most of my efforts was the testing of the implemented components. In particular, for each component composing the application I developed the associated test suite. As a consequence, I've learnt the fundamentals and basics of testing, including the rules and conventions to be followed, and of course the rudiments to develop functioning and effective testing suite. Given the fact that, because of my mostly economical-theoretical background, and the lack of previous "hands-on" coding experiences (especially in the context of Software Engineering), I must admit that I've made consistent use of GenAI tools to guide me throughout the work. However, everything I did and implemented was done with reason, ensuring I was always in control and aware of what I coded, especially considering what this application does and what is its purpose; testing, when dealing with a Password Manager, is the critical phase that ensures the application stays consistent and behaves consistently and deterministically, minimizing as much as possible the risk of it crashing or being compromised (i.e., leaking its content to malicious users). 
Thanks to this project, I've acquired awareness and knowledge about the carrying out of a teamwork-based software product, familiarizing with tools never used before (or, at least, not as much as I did for this project) like Github, Git, and Visual Studio Code. In the context of testing, I've also learnt how to interpret feedback error messages when doing coverage testing, and the whole concept of coverage. Furthermore, I was able to grasp the importance of testing at different levels, from unit to system and manual testing. 
To conclude, I'm really satisfied with what we've done as a group: the task was surely not one of the easiest to face, especially since we're all students with no computer science-oriented backgrounds. However, it is not just a matter of learning how to code, and how to test the code (in my specific case), but it is also about effectively working as a group, asynchronously yet coherently, with the view of finally implementing a functioning software product, exploiting as much as possible what we've covered during the lectures and the various tools. 

## ALBERTO

- An individual section is required for each member of the group
- Each member must self-evaluate their work, listing the strengths and weaknesses of the product
- Each member must describe their role within the group as objectively as possible
